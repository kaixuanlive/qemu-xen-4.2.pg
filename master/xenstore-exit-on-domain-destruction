diff -r 68fe19a3b321 sysemu.h
--- a/sysemu.h	Tue Nov 30 14:13:08 2010 +0000
+++ b/sysemu.h	Tue Nov 30 14:13:35 2010 +0000
@@ -28,9 +28,11 @@ void cpu_disable_ticks(void);
 void qemu_system_reset_request(void);
 void qemu_system_shutdown_request(void);
 void qemu_system_powerdown_request(void);
+void qemu_system_exit_request(void);
 int qemu_shutdown_requested(void);
 int qemu_reset_requested(void);
 int qemu_powerdown_requested(void);
+int qemu_exit_requested(void);
 #if !defined(TARGET_SPARC) && !defined(TARGET_I386)
 // Please implement a power failure function to signal the OS
 #define qemu_system_powerdown() do{}while(0)
diff -r 68fe19a3b321 vl.c
--- a/vl.c	Tue Nov 30 14:13:08 2010 +0000
+++ b/vl.c	Tue Nov 30 14:13:35 2010 +0000
@@ -3618,6 +3618,7 @@ static QEMUResetEntry *first_reset_entry
 static int reset_requested;
 static int shutdown_requested;
 static int powerdown_requested;
+static int exit_requested;
 
 int qemu_shutdown_requested(void)
 {
@@ -3640,6 +3641,13 @@ int qemu_powerdown_requested(void)
     return r;
 }
 
+int qemu_exit_requested(void)
+{
+    int r = exit_requested;
+    exit_requested = 0;
+    return r;
+}
+
 void qemu_register_reset(QEMUResetHandler *func, void *opaque)
 {
     QEMUResetEntry **pre, *re;
@@ -3693,6 +3701,11 @@ void qemu_system_powerdown_request(void)
         cpu_interrupt(cpu_single_env, CPU_INTERRUPT_EXIT);
 }
 
+void qemu_system_exit_request(void)
+{
+    exit_requested = 1;
+}
+
 #ifdef _WIN32
 static void host_main_loop_wait(int *timeout)
 {
@@ -3820,6 +3833,12 @@ void main_loop_wait(int timeout)
     }
 #endif
 
+    if (qemu_exit_requested()) {
+        /* Flush the cache and cancel outstanding aio requests */
+        bdrv_flush_all();
+        exit(0);
+    }
+
     /* vm time timers */
     if (vm_running && likely(!(cur_cpu->singlestep_enabled & SSTEP_NOTIMER)))
         qemu_run_timers(&active_timers[QEMU_TIMER_VIRTUAL],
diff -r 68fe19a3b321 xenstore.c
--- a/xenstore.c	Tue Nov 30 14:13:08 2010 +0000
+++ b/xenstore.c	Tue Nov 30 14:13:35 2010 +0000
@@ -528,6 +528,7 @@ void xenstore_parse_domain_config(int hv
     } else {
         guest_path = strdup(danger_path);
     }
+    xs_watch(xsh, "@releaseDomain", "releaseDomain");
 
     if (pasprintf(&buf, "%s/keymap", guest_path) != -1)
         xs_watch(xsh, buf, KEYMAP_TOKEN); // Ignore failure -- we can muddle on.i
@@ -1206,6 +1207,7 @@ void xenstore_process_event(void *opaque
 {
     char **vec, *offset, *bpath = NULL, *buf = NULL, *drv = NULL, *image = NULL;
     unsigned int len, num, hd_index, i;
+    xc_dominfo_t dominfo;
 
     vec = xs_read_watch(xsh, &num);
     if (!vec)
@@ -1240,6 +1242,13 @@ void xenstore_process_event(void *opaque
         goto out;
     }
 
+    if (!strcmp(vec[XS_WATCH_TOKEN], "releaseDomain") &&
+            (xc_domain_getinfo(xc_handle, domid, 1, &dominfo) != 1 ||
+             dominfo.domid != domid || dominfo.dying)) {
+        qemu_system_exit_request();
+        goto out;
+    }
+
     /* if we are paused don't process anything else */
     if (xen_pause_requested)
         goto out;
